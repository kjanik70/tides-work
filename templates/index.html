<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Tide Finder</title>
  <style>body{font-family:Arial,Helvetica,sans-serif;margin:24px;}label{display:block;margin-top:8px;}select,input{padding:6px;margin-top:4px;}table{border-collapse:collapse;width:100%;margin-top:12px}td,th{border:1px solid #ccc;padding:6px}button{margin-top:10px;padding:8px 12px}</style>
</head>
<body>
  <h1>Tide Finder</h1>
  <p>Choose a station, date range, time-of-day window, and minimum low tide level to find low tides.</p>
  <form method="post" action="/results">
    <label>State
      <select id="state-select" style="width:100%;padding:6px;"></select>
    </label>
    <label style="margin-top:8px">Station
      <select name="station" id="station-select" style="width:100%;padding:6px;"></select>
    </label>
    <div style="margin-top:8px;display:flex;gap:12px;align-items:center">
      <div id="station-meta" style="margin-top:8px;font-size:0.95rem;color:#333"></div>
      <div style="margin-left:16px;color:#666;font-size:0.9rem">Stations loaded: {{stations_count}}</div>
    </div>
    <label>Begin date
      <input type="date" name="begin_date" value="2025-10-11">
    </label>
    <label>End date
      <input type="date" name="end_date" value="2026-10-11">
    </label>
    <label>Start time of day
      <input type="time" name="start_time" value="08:00">
    </label>
    <label>End time of day
      <input type="time" name="end_time" value="19:00">
    </label>
    <label>Minimum low tide level (feet)
      <input type="number" step="0.01" name="min_level" value="0">
    </label>
    <button type="submit">Find low tides</button>
  </form>
  <div style="color:#b00;margin-top:10px">{{stations_error}}</div>
</body>
<script type="application/json" id="stations-data">{{stations_json}}</script>
<script>
// Try to parse the full embedded stations JSON. If it fails (too large or malformed),
// fall back to a smaller preview that the server also provides.
let stations = [];
let byState = {};
let stateList = [];
let initialized = false;
const stateSelect = document.getElementById('state-select');
const stationSelect = document.getElementById('station-select');
const meta = document.getElementById('station-meta');

function loadEmbeddedStations() {
  const dataScript = document.getElementById('stations-data');
  const raw = dataScript ? dataScript.textContent.trim() : '';
  try {
    if (raw && raw.length > 2) {
      stations = JSON.parse(raw);
      return stations.length > 0;
    }
  } catch (e) {
    console.warn('Failed to parse embedded stations JSON', e);
  }
  stations = [];
  return false;
}

function ensureStationsLoaded() {
  if (!stations.length) {
    meta.innerHTML = '<em>Loading stations…</em>';
  }
}

const haveEmbedded = loadEmbeddedStations();
if (haveEmbedded) {
  initStationUI();
} else {
  ensureStationsLoaded();
}

// Fetch stations data from the server-side endpoint. This keeps the HTML small
// and avoids issues with embedding very large JSON blobs inside templates.
fetch('/stations.json')
  .then(r => r.json())
  .then(data => {
    if (data && Array.isArray(data.stations) && data.stations.length) {
      stations = data.stations;
      initStationUI();
      return;
    }
    if (data && data.error) {
      console.error('stations.json error', data.error);
    } else {
      console.warn('stations.json returned unexpected payload', data);
    }
    if (!haveEmbedded) {
      stations = [];
      initStationUI();
    }
  })
  .catch(err => {
    console.error('Failed to fetch /stations.json', err);
    if (!haveEmbedded) {
      stations = [];
      initStationUI();
    }
  });
function labelFor(s) {
  const id = s.id || s.stationId || s.station || '';
  const name = s.name || s.stationName || '';
  return `${id} — ${name}`;
}

function showStationMetaByObj(s) {
  if (!s) { meta.innerHTML = ''; return; }
  meta.innerHTML = `<strong>${labelFor(s)}</strong>`;
}

function rebuildStateMaps() {
  byState = {};
  for (const s of stations) {
    const state = s.state || (s.address && s.address.state) || 'N/A';
    if (!byState[state]) byState[state] = [];
    byState[state].push(s);
  }
  stateList = Object.keys(byState).sort();
}

function populateStationsForState(state) {
  const list = byState[state] || [];
  stationSelect.innerHTML = list.map(s => `<option value="${s.id || s.stationId || s.station}">${labelFor(s)}</option>`).join('\n');
  if (list.length) {
    const first = list[0];
    const firstValue = first.id || first.stationId || first.station || '';
    if (firstValue) {
      stationSelect.value = firstValue;
    }
    showStationMetaByObj(first);
  } else {
    stationSelect.value = '';
    showStationMetaByObj(null);
  }
}

function initStationUI() {
  rebuildStateMaps();
  if (!stateList.length) {
    stateSelect.innerHTML = '<option value="">No stations available</option>';
    stationSelect.innerHTML = '';
    meta.innerHTML = '<em>No station data loaded.</em>';
    return;
  }
  stateSelect.innerHTML = stateList.map(st => `<option value="${st}">${st}</option>`).join('\n');

  const initialState = stateList.includes(stateSelect.value) ? stateSelect.value : stateList[0];
  stateSelect.value = initialState;
  populateStationsForState(initialState);

  if (!initialized) {
    stateSelect.addEventListener('change', (e) => {
      populateStationsForState(e.target.value);
    });
    stationSelect.addEventListener('change', (e) => {
      const val = e.target.value;
      const currentState = stateSelect.value;
      const s = (byState[currentState] || []).find(x => (x.id||x.stationId||x.station) == val);
      showStationMetaByObj(s);
    });
    initialized = true;
  }
}
</script>
</html>
